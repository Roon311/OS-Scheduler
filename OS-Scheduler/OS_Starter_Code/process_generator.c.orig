#include "Data_Structures/pcb_linked_list.h"
enum scheduling_algorithms {HPF, SRTN,RR };



///==============================
/*Implicit declerations*/
///==============================


void clear_resources(int);
void clear_resources_seg_fault(int);  //To catch segmentation faults

void fork_clk();

enum scheduling_algorithms ask_for_alg();

void read_input_file();

void init_comm_to_alg(enum scheduling_algorithms chosen_alg);

void init_schdular_alg(enum scheduling_algorithms chosen_alg);

void send_new_process_to_schedular();  

int g_q_key;
int msgqid;



int main(int argc, char * argv[])
{
    g_q_key=152001;
    signal(SIGINT, clear_resources);
    signal(SIGSEGV, clear_resources_seg_fault);

    enum scheduling_algorithms chosen_alg =ask_for_alg();


    read_input_file();
    init_comm_to_alg(chosen_alg);
    init_schdular_alg(chosen_alg);
    fork_clk();
    initClk();
    while(true)
    {
        printf("curr_clk: %d \n",getClk());

        send_new_process_to_schedular(getClk()); 
        sleep(1);       
    }

    destroyClk(true);
}

void clear_resources(int signum)
{
    //TODO Clears all resources in case of interruption
    destroyClk(true);
    msgctl(g_q_key, IPC_RMID, NULL);
    exit(EXIT_SUCCESS);

    
}
void clear_resources_seg_fault(int signum)
{
    //TODO Clears all resources in case of interruption
    printf("SegFault \n");
    clear_resources(signum);
}

void fork_clk()
{
    int pid;
    pid= fork();
    if (pid ==0)
    { //Child
        char *args[]={"./clk.out",NULL};
        execvp(args[0],args);

    }
}

enum scheduling_algorithms ask_for_alg()
{
    
    int answer;
    enum  scheduling_algorithms chosed_alg;

    while(!(answer ==1 || answer ==2 | answer ==3))
    {
        printf("Please specifiy an algorithm for sceduling. 1: HPF, 2: SRTN, 3: RR \n");
        scanf("%i", &answer);

        if(answer ==1)
        {
            printf("Working with HPF, highest priority first \n ");   
            return HPF;
        }
            
        if(answer ==2)
        {
            printf("Working with SRTN, Shortest remaing time next \n");   
            return SRTN;
        }
        if(answer ==3)
        {
            printf("Working with RR, Round robin \n");   
            return RR;
        }
    }
    

}

void read_input_file()
{
     static const char filename[] = "processes.txt";
    FILE * fPointer;
    fPointer = fopen(filename, "r");
    char singleLine[BUFSIZ];

    if(fPointer != NULL)
    {
        int ID, arrival, runtime, priority; 
        if ( fgets(singleLine, sizeof singleLine, fPointer) != NULL )
        {
            //Just to get rid of the first line in the file.
        }

        while ( fgets(singleLine, sizeof singleLine, fPointer) != NULL )
        {
            if ( sscanf(singleLine, "%d", &ID) == 1 && sscanf(singleLine, "%*d\t%d", &arrival) == 1 && sscanf(singleLine, "%*d\t%*d\t%d", &runtime) == 1 && sscanf(singleLine, "%*d\t%*d\t%*d\t%d", &priority) == 1)
            {
                insert_end(pu_create_process(ID,arrival,runtime,priority));
               
            }
        }
    }
    else
    {
        perror(filename);
    }
    fclose(fPointer);

    
    printf("Reading all processes from input file into pcb: \n");
    printf("█ 25%% Done\n\n");
    printf("█ █  50%% Done\n\n");
    printf("█ █ █  75%% Done\n\n");
    printf("█ █ █ █  100%% Done\n\n");
    printf("ALl file has been read into memory let's execute them by your specified algorithm \n");
}


void init_comm_to_alg(enum scheduling_algorithms chosed_alg)
{
    /*
        We will use message queue
        one message queue for all algorithms, and only one will use it.
    */
    int msgqid=msgget(g_q_key, IPC_CREAT);

}

void init_schdular_alg(enum scheduling_algorithms chosen_alg)
{
    /*
        shall be forking and execvp
    */

}


